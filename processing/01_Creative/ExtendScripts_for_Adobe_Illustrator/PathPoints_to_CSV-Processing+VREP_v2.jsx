// Initially developed March 2014 // at the Applied Research Lab in the Office of the CTO at Autodesk// by Maurice Conti, Stéphane Bersot, and Dr. Woohoo!var aDoc = app.activeDocument;var aLayer = aDoc.activeLayer;var destFolder = Folder.selectDialog('Select the folder to save the TXT file to:');var docName = "woohoo";var convertToMeters = false; // true for VREP, false for PROCESSINGif (convertToMeters) {      docName  += "_vrep";} else {      docName  += "_processing";    }    /*x,y,z,alpha,beta,gamma,relativeVelocity,BezierPointCount,interpolationFactor1,interpolationFactor2(x, y, z) represents a control point's position in METERS(alpha, beta, gamma) represents a control point's orientation given as Euler angles in DEGREES.RelativeVelocity represents a control point's relative velocity (for the generation of a velocity profile):– Range: BezierPointCount is the number of Bezier points that are desired for the control pointInterpolationFactor1 & InterpolationFactor2 are the interpolation factors    */pixelsToMeters=function(pixel) {  return mmToMeters(pixel * 0.264583);}mmToMeters=function(mm) { return mm * 0.001;}function getDistance(x1, y1, x2, y2, x3, y3){    var dx1 = x1 - x2;    var dy1 = y1 - y2;    var dxy1 = Math.sqrt ( dx1*dx1 + dy1*dy1);            var dx2 = x1 - x3;    var dy2 = y1 - y3;    var dxy2 = Math.sqrt ( dx2*dx2 + dy2*dy2);            return (dxy1+dxy2);    }    isCorner=function(x1, y1, ld1X, ld1Y, rd1X, rd1Y){    var corner = false;    // Calculate the sum of the distances between the 3 vectors and return this value        var distance = getDistance(x1,y1,ld1X,ld1Y,rd1X,rd1Y);    if (distance == 0) corner = true;    return [corner, distance];}saveDataToFile=function(fName, output) {    var csvFile = new File(fName);    csvFile.open("w");    csvFile.writeln(output);    csvFile.close();}calculateBezierPointCount=function(corner, distance){    // $.writeln("calculateBezierPointCount: " + corner+', '+distance);    var bezierPointCount;    if (corner)     {        bezierPointCount = 1;    } else {        var increaseOffset = 1.5;        bezierPointCount = Math.round( (distance*100)*increaseOffset );    }        return bezierPointCount;}generatePoints=function (){    // get the path(s)    var pItems = aLayer.pathItems;        var csvStr = '';    for (var i = 0; i < pItems.length; i++)    {        // get the points on a path        // csvStr  += "\n";        var verticalZ = 40;        var pPoints = pItems[i].pathPoints;        var closedPath = pItems[i].closed;        var firstPoint;        for (var j = 0; j < pPoints.length; j++)        {              var x = y = z = 0;              var alpha = 180;              var beta = 0;              var gamma = 180;              var relativeVelocity = 1.0;                            // BezierPointCount should be lower when their is less distance between the leftDirection, rightDirection and anchor points. Min = 1, Max = ~20              var bezierPointCount, interpolationFactor1, interpolationFactor2;                            // When the distance is lower and there are sharp corners, the interpolationFactors should be near 0.0. 0.99 indicates the greatest curve possible              // Prep for V-REP w/Curves              if (convertToMeters)              {                x = pixelsToMeters(pPoints[j].anchor[0]);                y = pixelsToMeters(pPoints[j].anchor[1]);                                // leftDirection, rightDirection                ldX = pixelsToMeters(pPoints[j].leftDirection[0]);                ldY = pixelsToMeters(pPoints[j].leftDirection[1]);                rdX = pixelsToMeters(pPoints[j].rightDirection[0]);                rdY = pixelsToMeters(pPoints[j].rightDirection[1]);                                                 // Determine if the current point is a corner as well as the distance between the points.                var cornerDistance = isCorner(x,y,ldX, ldY,rdX,rdY);                // $.writeln('\n'+j+': isCorner?: '+cornerDistance[0]+', distance: '+cornerDistance[1]);                                bezierPointCount = calculateBezierPointCount(cornerDistance[0], cornerDistance[1])                                // $.writeln('bezierPointCount: '+bezierPointCount);                                interpolationFactor1 = interpolationFactor2 = Number( ( (cornerDistance[1]*10)+0.01 ).toFixed(2) );                                                // If it's the 1st point of a new path, then move the z index higher                 if (j == 0) {                    var p1 = x+','+y + ','+pixelsToMeters(verticalZ)+ ','+alpha+ ','+beta+ ','+gamma+'\n';                                        var p2 = x+','+y + ','+pixelsToMeters(0)+ ','+alpha+ ','+beta+ ','+gamma+'\n';                    csvStr  += p1;                    csvStr  += p2;                    firstPoint = p1+p2;                } else if (j == pPoints.length-1) {                    // last point of a line                    csvStr  += x+','+y + ','+pixelsToMeters(0)+ ','+alpha+ ','+beta+ ','+gamma+'\n';                                                                                csvStr  += x+','+y + ','+pixelsToMeters(verticalZ)+ ','+alpha+ ','+beta+ ','+gamma+'\n';                                     } else  {                    csvStr  += x+','+y + ','+pixelsToMeters(0)+ ','+alpha+ ','+beta+ ','+gamma+'\n';                                                                            }                                                           // csvStr  += x+','+y + ','+z+ ','+alpha+ ','+beta+ ','+gamma+','+relativeVelocity+','+bezierPointCount+','+interpolationFactor1+','+interpolationFactor2+'\n';                                // if this is the last point, copy the 1st points info and use it here to close the curve                                              } else {                x = Math.round(pPoints[j].anchor[0]);                y = -(Math.round(pPoints[j].anchor[1]));                // If it's the 1st point of a new path, then move the z index higher                            if (j == 0) {                    // 1st point of a line                    var p1 = x+','+y + ','+verticalZ+'\n';                    var p2 = x+','+y + ','+0+'\n';                                    csvStr  += p1;                    csvStr  += p2;                    firstPoint = p1+p2;                                    } else if (j == pPoints.length-1) {                    // last point of a line                    csvStr  += x+','+y + ','+0+'\n';                     if (closedPath) {                        csvStr  += p2;                        csvStr  += p1;                    } else {                        csvStr  += p1;                    }                 } else  {                    csvStr  += x+','+y + ','+0+'\n';                                    }                                                // if this is the last point, copy the 1st points info and use it here to close the curve                                              }        }        }    // $.writeln(csvStr)    // export as a CSV file    if (destFolder) {        var destFile = new File(destFolder + '/'+docName+".txt");        saveDataToFile(destFile, csvStr);    }    }generatePoints();    